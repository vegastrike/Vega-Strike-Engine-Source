/*
 * configuration.cpp
 *
 * Copyright (C) 2021-2022 Daniel Horn, Roy Falk, ministerofinformation,
 * David Wales, Stephen G. Tuggy, and other Vega Strike contributors
 *
 * https://github.com/vegastrike/Vega-Strike-Engine-Source
 *
 * This file is part of Vega Strike.
 *
 * Vega Strike is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * Vega Strike is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Vega Strike. If not, see <https://www.gnu.org/licenses/>.
 */

// This file has been autogenerated by JsonStruct. Do not modify it directly.

#ifndef VEGA_STRIKE_ENGINE_CONFIG_CONFIGURATION_H
#define VEGA_STRIKE_ENGINE_CONFIG_CONFIGURATION_H

#include <string>
#include <memory>


struct Configuration {
    Configuration(const std::string json_text);
    

	struct {
		int screen = 0;
		int pitch = 0;
		int yaw = 0;
		int roll = 0;
		bool force_anonymous_mission_names = true;
		bool write_savegame_on_exit = true;
		int times_to_show_help_screen = 3;
		bool remember_savegame = true;
		std::string new_game_save_name = "New_Game";
		int quick_savegame_summaries_buffer = 16384;
		std::string empty_mission = "internal.mission";
		std::string custom_python = "import custom;custom.processMessage";
		bool quick_savegame_summaries = true;
		int garbage_collect_frequency = 20;
		int num_old_systems = 6;
		bool delete_old_systems = true;
		bool while_loading_star_system = false;
	} general;

	struct {
		bool always_obedient = true;
		bool assist_friend_in_need = true;
		double ease_to_anger = -0.5;
		double ease_to_appease = 0.5;
		int hull_damage_anger = 10;
		double hull_percent_for_comm = 0.75;
		double lowest_negative_comm_choice = -1e-05;
		int lowest_positive_comm_choice = 0;
		double mood_swing_level = 0.2;
		double random_response_range = 0.8;
		int shield_damage_anger = 1;
		bool jump_without_energy = false;
		double friend_factor = 0.1;
		double kill_factor = 0.2;
		int min_relationship = -20;

		struct {
			double missile_probability = 0.01;
			int aggressivity = 15;
		} firing;

		struct {
			int escort_distance = 10;
			int turn_leader_distance = 5;
			int time_to_recommand_wing = 100;
			int min_time_to_switch_targets = 3;
		} targeting;
	} ai;

	struct {
		bool clear_history_on_list_change = false;
		bool every_other_mount = false;
	} audio;

	struct {
		int collision_hack_distance = 0;
		int collision_damage_to_ai = 0;
		bool crash_dock_hangar = false;
		bool crash_dock_unit = false;
		int front_collision_hack_angle = 40;
		int front_collision_hack_distance = 200000;
		bool cargo_deals_collide_damage = false;
		std::string upgrade_faction = "(cargo_deals_collide_damage ? -1 : FactionUtil::GetUpgradeFaction())";
	} collision;

	struct {
		int default_lock_cone = 0;
		int default_max_range = 0;
		int default_tracking_cone = 0;
	} computer;

	struct {
		std::string master_part_list = "master_part_list";
		bool using_templates = true;
	} data;

	struct {
		int eject_cargo_percent = 1;
		int max_dumped_cargo = 15;
		int hull_damage_to_eject = 100;
		double auto_eject_percent = 0.5;
		bool player_auto_eject = true;
	} eject;

	struct {
		int afterburner_fuel_usage = 1;
		int fuel_efficiency = 1;
		bool fuel_equals_warp = false;
		bool normal_fuel_usage = true;
		bool reactor_uses_fuel = true;
		double vsd_mj_yield = 5.4;
		double no_fuel_thrust = 0.4;
		double no_fuel_afterburn = 0.1;
		bool variable_fuel_consumption = false;
		int deuterium_relative_efficiency_lithium = 1;
		double fmec_factor = 8e-09;
		double reactor_idle_efficiency = 0.98;
		double min_reactor_efficiency = 1e-05;
		double ecm_energy_cost = 0.05;
		int megajoules_factor = 100;
		int fuel_factor = 60;
		int energy_factor = 1;
		int ftl_energy_factor = 1;
		int reactor_factor = 1;
		double ftl_drive_factor = 0.1;
		int jump_drive_factor = 1;
		double shield_maintenance_factor = 0.01;
		double shield_regeneration_factor = 0.1;
		std::string drive_source = "Fuel";
		std::string reactor_source = "Fuel";
		std::string afterburner_source = "Fuel";
		std::string jump_drive_source = "FTLEnergy";
		std::string cloak_source = "Energy";
		double minimum_drive = 0.15;
	} fuel;

	struct {
		bool draw_rendered_crosshairs = true;
		std::string already_near_message = "#ff0000Already Near#000000";
		double armor_hull_size = 0.55;
		std::string asteroids_near_message = "#ff0000Asteroids Near#000000";
		bool basename_colon_basename = true;
		int box_line_thickness = 1;
		bool completed_objectives_last = true;
		bool crosshairs_on_chase_cam = false;
		bool crosshairs_on_padlock = false;
		std::string damage_report_heading = "#00ff00DAMAGE REPORT\n\n";
		bool debug_position = false;
		int diamond_line_thickness = 1;
		int diamond_rotation_speed = 1;
		double diamond_size = 2.05;
		bool display_relative_velocity = true;
		bool display_warp_energy_if_no_jump_drive = true;
		bool draw_all_target_boxes = false;
		bool draw_always_itts = false;
		bool draw_line_to_itts = false;
		bool draw_line_to_target = false;
		bool draw_line_to_targets_target = false;
		bool draw_nav_symbol = false;
		bool draw_tactical_target = false;
		bool draw_targeting_boxes = true;
		bool draw_targeting_boxes_inside = true;
		bool draw_arrow_on_chase_cam = true;
		bool draw_arrow_on_pan_cam = false;
		bool draw_arrow_on_pan_target = false;
		bool draw_arrow_to_target = true;
		bool draw_blips_on_both_radar = false;
		bool draw_damage_sprite = true;
		bool draw_gravitational_objects = true;
		bool draw_nav_grid = true;
		bool draw_significant_blips = true;
		bool draw_star_direction = true;
		bool draw_unit_on_chase_cam = true;
		bool draw_vdu_view_shields = true;
		bool draw_weapon_sprite = false;
		std::string enemy_near_message = "#ff0000Enemy Near#000000";
		int gun_list_columns = 1;
		bool invert_friendly_shields = false;
		bool invert_friendly_sprite = false;
		bool invert_target_shields = false;
		bool invert_target_sprite = false;
		bool invert_view_shields = false;
		bool itts_for_beams = false;
		bool itts_for_lockable = false;
		double itts_line_to_mark_alpha = 0.1;
		bool itts_use_average_gun_speed = true;
		bool lock_center_crosshair = false;
		double lock_confirm_line_length = 1.5;
		std::string manifest_heading = "Manifest\n";
		double max_missile_bracket_size = 2.05;
		std::string message_prefix = "";
		double min_missile_bracket_size = 1.05;
		double min_lock_box_size = 0.001;
		int min_radar_blip_size = 0;
		double min_target_box_size = 0.01;
		std::string mounts_list_empty = "";
		int nav_cross_line_thickness = 1;
		std::string not_included_in_damage_report = "plasteel_hull tungsten_hull isometal_hull";
		bool out_of_cone_distance = false;
		double padlock_view_lag = 1.5;
		double padlock_view_lag_fix_zone = 0.0872;
		std::string planet_near_message = "#ff0000Planetary Hazard Near#000000";
		bool print_damage_percent = true;
		bool print_faction = true;
		bool print_fg_name = true;
		bool print_fg_sub_id = false;
		bool print_request_docking = true;
		bool print_ship_type = true;
		bool projectile_means_missile = false;
		std::string radar_type = "WC";
		int radar_search_extra_radius = 1000;
		bool rotating_bracket_inner = true;
		double rotating_bracket_size = 0.58;
		double rotating_bracket_width = 0.1;
		int scale_relationship_color = 10;
		bool shield_vdu_fade = true;
		int shield_vdu_thresh0 = 0;
		double shield_vdu_thresh1 = 0.33;
		double shield_vdu_thresh2 = 0.66;
		bool show_negative_blips_as_positive = true;
		bool simple_manifest = false;
		std::string starship_near_message = "#ff0000Starship Near#000000";
		bool switch_to_target_mode_on_key = true;
		bool switch_back_from_comms = true;
		double tac_target_foci = 0.5;
		double tac_target_length = 0.1;
		int tac_target_thickness = 1;
		double text_background_alpha = 0.0625;
		bool top_view = false;
		bool untarget_beyond_cone = false;
	} hud;

	struct {
		int resolution_x = 2560;
		int resolution_y = 1600;
		int screen = 0;

		struct {
			int flicker_time = 30;
			int flicker_off_time = 2;
			int min_flicker_cycle = 2;
			double num_times_per_second_on = 0.66;
			double hull_for_total_dark = 0.04;
		} glow_flicker;
		std::string automatic_landing_zone_warning = "comm_docking.ani";
		std::string automatic_landing_zone_warning1 = "comm_docking.ani";
		std::string automatic_landing_zone_warning2 = "comm_docking.ani";
		std::string automatic_landing_zone_warning_text = "Now Entering an Automatic Landing Zone.";
		bool draw_heading_marker = false;
		int missile_explosion_radius_mult = 1;
		bool missile_sparkle = false;
		int in_system_jump_ani_second_ahead = 4;
		double in_system_jump_ani_second_ahead_end = 0.03;
		std::string in_system_jump_animation = "warp.ani";
		int atmosphere_emmissive = 1;
		int atmosphere_diffuse = 1;
		double default_engine_activation = 0.00048828125;
		std::string explosion_animation = "explosion_orange.ani";
		int shield_detail = 16;
		std::string shield_texture = "shield.bmp";
		std::string shield_technique = "";
		int fov = 78;
		int reduced_vdus_width = 0;
		int reduced_vdus_height = 0;
		double star_body_radius = 0.33;
		bool draw_star_glow = true;
		bool draw_star_body = true;
		double star_glow_radius = 1.33;
		bool glow_ambient_star_light = false;
		bool glow_diffuse_star_light = false;
		int planet_detail_stacks = 24;
		std::string wormhole_unit = "wormhole";
		int city_light_strength = 10;
		int day_city_light_strength = 0;
		int num_times_to_draw_shine = 2;
	} graphics;

	struct {
		int vsdebug = 0;
		bool verbose_debug = false;
	} logging;

	struct {
		int collision_scale_factor = 1;
		int inelastic_scale = 1;
		int kilojoules_per_damage = 1;
		int max_force_multiplier = 1;
		int max_shield_lowers_capacitance = 1;
		int max_torque_multiplier = 1;
		double minimum_mass = 1.0;
		int minimum_time = 1;
		bool does_missile_bounce = false;
		int default_shield_tightness = 0;
		bool system_damage_on_armor = false;
		double indiscriminate_system_destruction = 0.25;
		bool separate_system_flakiness_component = false;
		double shield_energy_capacitance = 0.2;
		bool use_max_shield_energy_usage = false;
		bool shields_in_spec = false;
		double shield_maintenance_charge = 0.25;
		int max_ecm = 4;
		double max_lost_target_live_time = 30.0;
		int percent_missile_match_target_velocity = 1;
		int game_speed = 1;
		int game_accel = 1;
		int combat_mode_multiplier = 100;
		int velocity_max = 10000;
		int max_player_rotation_rate = 24;
		int max_non_player_rotation_rate = 360;
		int capship_size = 500;
		double near_autotrack_cone = 0.9;
		int close_enough_to_autotrack = 4;
		int distance_to_warp = 1000000000000;
		double target_distance_to_warp_bonus = 1.33;
		bool no_spec_jump = true;
		double difficulty_speed_exponent = 0.2;
		double min_damage = 0.001;
		double max_damage = 0.999;
		double max_radar_cone_damage = 0.9;
		double max_radar_lock_cone_damage = 0.95;
		double max_radar_track_cone_damage = 0.98;
		double thruster_hit_chance = 0.25;
		int friendly_auto_radius = 0;
		int neutral_auto_radius = 0;
		int hostile_auto_radius = 1000;
		int min_asteroid_distance = -100;
		bool steady_itts = false;
		bool no_unit_collisions = false;
		bool difficulty_based_shield_recharge = true;
		bool engine_energy_takes_priority = true;
		int density_of_rock = 3;
		int density_of_jump_point = 100000;
		double planet_dock_port_size = 1.2;
		int planet_dock_port_min_size = 300;
		double jump_mesh_radius_scale = 0.5;
		bool planets_can_have_subunits = false;
		bool planets_always_neutral = true;
		bool no_damage_to_docked_ships = true;
		bool difficulty_based_enemy_damage = true;
		double speeding_discharge = 0.25;
		double min_shield_speeding_discharge = 0.1;
		double nebula_shield_recharge = 0.5;
	} physics;

	struct {
		double default_aggressivity = 2.01;
	} unit;

	struct {
		double insystem_jump_cost = 0.1;
		double max_effective_velocity = 2960881320.33;
		int bleed_factor = 2;
		double warp_energy_multiplier = 0.12;
		double player_warp_energy_multiplier = 0.12;
		int warp_ramp_up_time = 5;
		int computer_warp_ramp_up_time = 10;
		double warp_ramp_down_time = 0.5;
		double warp_memory_effect = 0.9;
		int warp_stretch_cutoff = 500000;
		int warp_stretch_decel_cutoff = 500000;
		double warp_multiplier_min = 9.86968440109;
		int warp_multiplier_max = 300000000;
		bool use_warp_energy_for_cloak = true;
	} ftl;

	struct {
		bool can_fire_in_cloak = false;
		bool can_fire_in_spec = false;
	} weapons;

	struct {

		struct {

		} afterburner;

		struct {
			int non_combat_mode_multiplier = 100;
		} drive;

		struct {
			int factor = 1;
		} energy;

		struct {
			bool fuel_equals_warp = false;
			int factor = 600;
		} fuel2;

		struct {
			double factor = 0.1;
		} ftl_drive;

		struct {
			int factor = 1;
		} ftl_energy;

		struct {
			int factor = 1;
		} jump_drive;

		struct {
			int factor = 1;
		} reactor;
	} components;

	struct {
		int megajoules_multiplier = 100;
		int kilo = 1000;
		int kj_per_unit_damage = 5400;
	} constants;

	struct {
		std::string default_mission = "main_menu.mission";
		std::string introduction = "Welcome to Vega Strike!\nUse #8080FFTab#000000 to afterburn (#8080FF+,-#000000 cruise control),\n#8080FFarrows#000000 to steer.\nThe #8080FFt#000000 key targets objects; #8080FFspace#000000 fires at them & #8080FFa#000000 activates the SPEC drive.\nTo go to another star system, buy a jump drive for about 10000 credits,\nfly to a wireframe jump-point and press #8080FFj#000000 to warp to a near star.\nTarget a base or planet;\nWhen you get close a green box will appear. Inside the box, #8080FFd#000000 will land.";
	} game_start;

	struct {

	} advanced;
};

extern std::shared_ptr<Configuration> configuration();

#endif //VEGA_STRIKE_ENGINE_CONFIG_CONFIGURATION_H