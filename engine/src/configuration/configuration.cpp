/*
 * configuration.h
 *
 * Copyright (C) 2021-2023 Daniel Horn, Roy Falk, ministerofinformation,
 * David Wales, Stephen G. Tuggy, Benjamen R. Meyer, and other Vega Strike contributors
 *
 * https://github.com/vegastrike/Vega-Strike-Engine-Source
 *
 * This file is part of Vega Strike.
 *
 * Vega Strike is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * Vega Strike is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Vega Strike. If not, see <https://www.gnu.org/licenses/>.
 */

// This file has been autogenerated by JsonStruct. Do not modify it directly.

#include <iostream>
#include <exception>
#include <boost/json.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

#include "configuration.h"

Configuration::Configuration(const std::string json_text) {
    try {
        boost::json::value json_value = boost::json::parse(json_text);
        boost::json::object root_object = json_value.get_object();


		boost::json::object general_object = root_object.at("general").get_object();
		general.screen = boost::json::value_to<int>(general_object.at("screen"));
		general.pitch = boost::json::value_to<int>(general_object.at("pitch"));
		general.yaw = boost::json::value_to<int>(general_object.at("yaw"));
		general.roll = boost::json::value_to<int>(general_object.at("roll"));
		general.force_anonymous_mission_names = boost::json::value_to<bool>(general_object.at("force_anonymous_mission_names"));
		general.write_savegame_on_exit = boost::json::value_to<bool>(general_object.at("write_savegame_on_exit"));
		general.times_to_show_help_screen = boost::json::value_to<int>(general_object.at("times_to_show_help_screen"));
		general.remember_savegame = boost::json::value_to<bool>(general_object.at("remember_savegame"));
		general.new_game_save_name = boost::json::value_to<std::string>(general_object.at("new_game_save_name"));
		general.quick_savegame_summaries_buffer = boost::json::value_to<int>(general_object.at("quick_savegame_summaries_buffer"));
		general.empty_mission = boost::json::value_to<std::string>(general_object.at("empty_mission"));
		general.custom_python = boost::json::value_to<std::string>(general_object.at("custom_python"));
		general.quick_savegame_summaries = boost::json::value_to<bool>(general_object.at("quick_savegame_summaries"));
		general.garbage_collect_frequency = boost::json::value_to<int>(general_object.at("garbage_collect_frequency"));
		general.num_old_systems = boost::json::value_to<int>(general_object.at("num_old_systems"));
		general.delete_old_systems = boost::json::value_to<bool>(general_object.at("delete_old_systems"));
		general.while_loading_star_system = boost::json::value_to<bool>(general_object.at("while_loading_star_system"));

		boost::json::object ai_object = root_object.at("ai").get_object();
		ai.always_obedient = boost::json::value_to<bool>(ai_object.at("always_obedient"));
		ai.assist_friend_in_need = boost::json::value_to<bool>(ai_object.at("assist_friend_in_need"));
		ai.ease_to_anger = boost::json::value_to<double>(ai_object.at("ease_to_anger"));
		ai.ease_to_appease = boost::json::value_to<double>(ai_object.at("ease_to_appease"));
		ai.hull_damage_anger = boost::json::value_to<int>(ai_object.at("hull_damage_anger"));
		ai.hull_percent_for_comm = boost::json::value_to<double>(ai_object.at("hull_percent_for_comm"));
		ai.lowest_negative_comm_choice = boost::json::value_to<double>(ai_object.at("lowest_negative_comm_choice"));
		ai.lowest_positive_comm_choice = boost::json::value_to<int>(ai_object.at("lowest_positive_comm_choice"));
		ai.mood_swing_level = boost::json::value_to<double>(ai_object.at("mood_swing_level"));
		ai.random_response_range = boost::json::value_to<double>(ai_object.at("random_response_range"));
		ai.shield_damage_anger = boost::json::value_to<int>(ai_object.at("shield_damage_anger"));
		ai.jump_without_energy = boost::json::value_to<bool>(ai_object.at("jump_without_energy"));
		ai.friend_factor = boost::json::value_to<double>(ai_object.at("friend_factor"));
		ai.kill_factor = boost::json::value_to<double>(ai_object.at("kill_factor"));
		ai.min_relationship = boost::json::value_to<int>(ai_object.at("min_relationship"));

		boost::json::object firing_object = ai_object.at("firing").get_object();
		ai.firing.missile_probability = boost::json::value_to<double>(firing_object.at("missile_probability"));
		ai.firing.aggressivity = boost::json::value_to<int>(firing_object.at("aggressivity"));

		boost::json::object targeting_object = ai_object.at("targeting").get_object();
		ai.targeting.escort_distance = boost::json::value_to<int>(targeting_object.at("escort_distance"));
		ai.targeting.turn_leader_distance = boost::json::value_to<int>(targeting_object.at("turn_leader_distance"));
		ai.targeting.time_to_recommand_wing = boost::json::value_to<int>(targeting_object.at("time_to_recommand_wing"));
		ai.targeting.min_time_to_switch_targets = boost::json::value_to<int>(targeting_object.at("min_time_to_switch_targets"));

		boost::json::object audio_object = root_object.at("audio").get_object();
		audio.clear_history_on_list_change = boost::json::value_to<bool>(audio_object.at("clear_history_on_list_change"));
		audio.every_other_mount = boost::json::value_to<bool>(audio_object.at("every_other_mount"));

		boost::json::object collision_object = root_object.at("collision").get_object();
		collision.collision_hack_distance = boost::json::value_to<int>(collision_object.at("collision_hack_distance"));
		collision.collision_damage_to_ai = boost::json::value_to<int>(collision_object.at("collision_damage_to_ai"));
		collision.crash_dock_hangar = boost::json::value_to<bool>(collision_object.at("crash_dock_hangar"));
		collision.crash_dock_unit = boost::json::value_to<bool>(collision_object.at("crash_dock_unit"));
		collision.front_collision_hack_angle = boost::json::value_to<int>(collision_object.at("front_collision_hack_angle"));
		collision.front_collision_hack_distance = boost::json::value_to<int>(collision_object.at("front_collision_hack_distance"));
		collision.cargo_deals_collide_damage = boost::json::value_to<bool>(collision_object.at("cargo_deals_collide_damage"));
		collision.upgrade_faction = boost::json::value_to<std::string>(collision_object.at("upgrade_faction"));

		boost::json::object computer_object = root_object.at("computer").get_object();
		computer.default_lock_cone = boost::json::value_to<int>(computer_object.at("default_lock_cone"));
		computer.default_max_range = boost::json::value_to<int>(computer_object.at("default_max_range"));
		computer.default_tracking_cone = boost::json::value_to<int>(computer_object.at("default_tracking_cone"));

		boost::json::object data_object = root_object.at("data").get_object();
		data.master_part_list = boost::json::value_to<std::string>(data_object.at("master_part_list"));
		data.using_templates = boost::json::value_to<bool>(data_object.at("using_templates"));

		boost::json::object eject_object = root_object.at("eject").get_object();
		eject.eject_cargo_percent = boost::json::value_to<int>(eject_object.at("eject_cargo_percent"));
		eject.max_dumped_cargo = boost::json::value_to<int>(eject_object.at("max_dumped_cargo"));
		eject.hull_damage_to_eject = boost::json::value_to<int>(eject_object.at("hull_damage_to_eject"));
		eject.auto_eject_percent = boost::json::value_to<double>(eject_object.at("auto_eject_percent"));
		eject.player_auto_eject = boost::json::value_to<bool>(eject_object.at("player_auto_eject"));

		boost::json::object fuel_object = root_object.at("fuel").get_object();
		fuel.afterburner_fuel_usage = boost::json::value_to<int>(fuel_object.at("afterburner_fuel_usage"));
		fuel.fuel_efficiency = boost::json::value_to<int>(fuel_object.at("fuel_efficiency"));
		fuel.fuel_equals_warp = boost::json::value_to<bool>(fuel_object.at("fuel_equals_warp"));
		fuel.normal_fuel_usage = boost::json::value_to<bool>(fuel_object.at("normal_fuel_usage"));
		fuel.reactor_uses_fuel = boost::json::value_to<bool>(fuel_object.at("reactor_uses_fuel"));
		fuel.vsd_mj_yield = boost::json::value_to<double>(fuel_object.at("vsd_mj_yield"));
		fuel.no_fuel_thrust = boost::json::value_to<double>(fuel_object.at("no_fuel_thrust"));
		fuel.no_fuel_afterburn = boost::json::value_to<double>(fuel_object.at("no_fuel_afterburn"));
		fuel.variable_fuel_consumption = boost::json::value_to<bool>(fuel_object.at("variable_fuel_consumption"));
		fuel.deuterium_relative_efficiency_lithium = boost::json::value_to<int>(fuel_object.at("deuterium_relative_efficiency_lithium"));
		fuel.fmec_factor = boost::json::value_to<double>(fuel_object.at("fmec_factor"));
		fuel.reactor_idle_efficiency = boost::json::value_to<double>(fuel_object.at("reactor_idle_efficiency"));
		fuel.min_reactor_efficiency = boost::json::value_to<double>(fuel_object.at("min_reactor_efficiency"));
		fuel.ecm_energy_cost = boost::json::value_to<double>(fuel_object.at("ecm_energy_cost"));
		fuel.megajoules_factor = boost::json::value_to<int>(fuel_object.at("megajoules_factor"));
		fuel.fuel_factor = boost::json::value_to<int>(fuel_object.at("fuel_factor"));
		fuel.energy_factor = boost::json::value_to<int>(fuel_object.at("energy_factor"));
		fuel.ftl_energy_factor = boost::json::value_to<int>(fuel_object.at("ftl_energy_factor"));
		fuel.reactor_factor = boost::json::value_to<int>(fuel_object.at("reactor_factor"));
		fuel.ftl_drive_factor = boost::json::value_to<double>(fuel_object.at("ftl_drive_factor"));
		fuel.jump_drive_factor = boost::json::value_to<int>(fuel_object.at("jump_drive_factor"));
		fuel.shield_maintenance_factor = boost::json::value_to<double>(fuel_object.at("shield_maintenance_factor"));
		fuel.shield_regeneration_factor = boost::json::value_to<double>(fuel_object.at("shield_regeneration_factor"));
		fuel.drive_source = boost::json::value_to<std::string>(fuel_object.at("drive_source"));
		fuel.reactor_source = boost::json::value_to<std::string>(fuel_object.at("reactor_source"));
		fuel.afterburner_source = boost::json::value_to<std::string>(fuel_object.at("afterburner_source"));
		fuel.jump_drive_source = boost::json::value_to<std::string>(fuel_object.at("jump_drive_source"));
		fuel.cloak_source = boost::json::value_to<std::string>(fuel_object.at("cloak_source"));
		fuel.minimum_drive = boost::json::value_to<double>(fuel_object.at("minimum_drive"));

		boost::json::object hud_object = root_object.at("hud").get_object();
		hud.draw_rendered_crosshairs = boost::json::value_to<bool>(hud_object.at("draw_rendered_crosshairs"));
		hud.already_near_message = boost::json::value_to<std::string>(hud_object.at("already_near_message"));
		hud.armor_hull_size = boost::json::value_to<double>(hud_object.at("armor_hull_size"));
		hud.asteroids_near_message = boost::json::value_to<std::string>(hud_object.at("asteroids_near_message"));
		hud.basename_colon_basename = boost::json::value_to<bool>(hud_object.at("basename_colon_basename"));
		hud.box_line_thickness = boost::json::value_to<int>(hud_object.at("box_line_thickness"));
		hud.completed_objectives_last = boost::json::value_to<bool>(hud_object.at("completed_objectives_last"));
		hud.crosshairs_on_chase_cam = boost::json::value_to<bool>(hud_object.at("crosshairs_on_chase_cam"));
		hud.crosshairs_on_padlock = boost::json::value_to<bool>(hud_object.at("crosshairs_on_padlock"));
		hud.damage_report_heading = boost::json::value_to<std::string>(hud_object.at("damage_report_heading"));
		hud.debug_position = boost::json::value_to<bool>(hud_object.at("debug_position"));
		hud.diamond_line_thickness = boost::json::value_to<int>(hud_object.at("diamond_line_thickness"));
		hud.diamond_rotation_speed = boost::json::value_to<int>(hud_object.at("diamond_rotation_speed"));
		hud.diamond_size = boost::json::value_to<double>(hud_object.at("diamond_size"));
		hud.display_relative_velocity = boost::json::value_to<bool>(hud_object.at("display_relative_velocity"));
		hud.display_warp_energy_if_no_jump_drive = boost::json::value_to<bool>(hud_object.at("display_warp_energy_if_no_jump_drive"));
		hud.draw_all_target_boxes = boost::json::value_to<bool>(hud_object.at("draw_all_target_boxes"));
		hud.draw_always_itts = boost::json::value_to<bool>(hud_object.at("draw_always_itts"));
		hud.draw_line_to_itts = boost::json::value_to<bool>(hud_object.at("draw_line_to_itts"));
		hud.draw_line_to_target = boost::json::value_to<bool>(hud_object.at("draw_line_to_target"));
		hud.draw_line_to_targets_target = boost::json::value_to<bool>(hud_object.at("draw_line_to_targets_target"));
		hud.draw_nav_symbol = boost::json::value_to<bool>(hud_object.at("draw_nav_symbol"));
		hud.draw_tactical_target = boost::json::value_to<bool>(hud_object.at("draw_tactical_target"));
		hud.draw_targeting_boxes = boost::json::value_to<bool>(hud_object.at("draw_targeting_boxes"));
		hud.draw_targeting_boxes_inside = boost::json::value_to<bool>(hud_object.at("draw_targeting_boxes_inside"));
		hud.draw_arrow_on_chase_cam = boost::json::value_to<bool>(hud_object.at("draw_arrow_on_chase_cam"));
		hud.draw_arrow_on_pan_cam = boost::json::value_to<bool>(hud_object.at("draw_arrow_on_pan_cam"));
		hud.draw_arrow_on_pan_target = boost::json::value_to<bool>(hud_object.at("draw_arrow_on_pan_target"));
		hud.draw_arrow_to_target = boost::json::value_to<bool>(hud_object.at("draw_arrow_to_target"));
		hud.draw_blips_on_both_radar = boost::json::value_to<bool>(hud_object.at("draw_blips_on_both_radar"));
		hud.draw_damage_sprite = boost::json::value_to<bool>(hud_object.at("draw_damage_sprite"));
		hud.draw_gravitational_objects = boost::json::value_to<bool>(hud_object.at("draw_gravitational_objects"));
		hud.draw_nav_grid = boost::json::value_to<bool>(hud_object.at("draw_nav_grid"));
		hud.draw_significant_blips = boost::json::value_to<bool>(hud_object.at("draw_significant_blips"));
		hud.draw_star_direction = boost::json::value_to<bool>(hud_object.at("draw_star_direction"));
		hud.draw_unit_on_chase_cam = boost::json::value_to<bool>(hud_object.at("draw_unit_on_chase_cam"));
		hud.draw_vdu_view_shields = boost::json::value_to<bool>(hud_object.at("draw_vdu_view_shields"));
		hud.draw_weapon_sprite = boost::json::value_to<bool>(hud_object.at("draw_weapon_sprite"));
		hud.enemy_near_message = boost::json::value_to<std::string>(hud_object.at("enemy_near_message"));
		hud.gun_list_columns = boost::json::value_to<int>(hud_object.at("gun_list_columns"));
		hud.invert_friendly_shields = boost::json::value_to<bool>(hud_object.at("invert_friendly_shields"));
		hud.invert_friendly_sprite = boost::json::value_to<bool>(hud_object.at("invert_friendly_sprite"));
		hud.invert_target_shields = boost::json::value_to<bool>(hud_object.at("invert_target_shields"));
		hud.invert_target_sprite = boost::json::value_to<bool>(hud_object.at("invert_target_sprite"));
		hud.invert_view_shields = boost::json::value_to<bool>(hud_object.at("invert_view_shields"));
		hud.itts_for_beams = boost::json::value_to<bool>(hud_object.at("itts_for_beams"));
		hud.itts_for_lockable = boost::json::value_to<bool>(hud_object.at("itts_for_lockable"));
		hud.itts_line_to_mark_alpha = boost::json::value_to<double>(hud_object.at("itts_line_to_mark_alpha"));
		hud.itts_use_average_gun_speed = boost::json::value_to<bool>(hud_object.at("itts_use_average_gun_speed"));
		hud.lock_center_crosshair = boost::json::value_to<bool>(hud_object.at("lock_center_crosshair"));
		hud.lock_confirm_line_length = boost::json::value_to<double>(hud_object.at("lock_confirm_line_length"));
		hud.manifest_heading = boost::json::value_to<std::string>(hud_object.at("manifest_heading"));
		hud.max_missile_bracket_size = boost::json::value_to<double>(hud_object.at("max_missile_bracket_size"));
		hud.message_prefix = boost::json::value_to<std::string>(hud_object.at("message_prefix"));
		hud.min_missile_bracket_size = boost::json::value_to<double>(hud_object.at("min_missile_bracket_size"));
		hud.min_lock_box_size = boost::json::value_to<double>(hud_object.at("min_lock_box_size"));
		hud.min_radar_blip_size = boost::json::value_to<int>(hud_object.at("min_radar_blip_size"));
		hud.min_target_box_size = boost::json::value_to<double>(hud_object.at("min_target_box_size"));
		hud.mounts_list_empty = boost::json::value_to<std::string>(hud_object.at("mounts_list_empty"));
		hud.nav_cross_line_thickness = boost::json::value_to<int>(hud_object.at("nav_cross_line_thickness"));
		hud.not_included_in_damage_report = boost::json::value_to<std::string>(hud_object.at("not_included_in_damage_report"));
		hud.out_of_cone_distance = boost::json::value_to<bool>(hud_object.at("out_of_cone_distance"));
		hud.padlock_view_lag = boost::json::value_to<double>(hud_object.at("padlock_view_lag"));
		hud.padlock_view_lag_fix_zone = boost::json::value_to<double>(hud_object.at("padlock_view_lag_fix_zone"));
		hud.planet_near_message = boost::json::value_to<std::string>(hud_object.at("planet_near_message"));
		hud.print_damage_percent = boost::json::value_to<bool>(hud_object.at("print_damage_percent"));
		hud.print_faction = boost::json::value_to<bool>(hud_object.at("print_faction"));
		hud.print_fg_name = boost::json::value_to<bool>(hud_object.at("print_fg_name"));
		hud.print_fg_sub_id = boost::json::value_to<bool>(hud_object.at("print_fg_sub_id"));
		hud.print_request_docking = boost::json::value_to<bool>(hud_object.at("print_request_docking"));
		hud.print_ship_type = boost::json::value_to<bool>(hud_object.at("print_ship_type"));
		hud.projectile_means_missile = boost::json::value_to<bool>(hud_object.at("projectile_means_missile"));
		hud.radar_type = boost::json::value_to<std::string>(hud_object.at("radar_type"));
		hud.radar_search_extra_radius = boost::json::value_to<int>(hud_object.at("radar_search_extra_radius"));
		hud.rotating_bracket_inner = boost::json::value_to<bool>(hud_object.at("rotating_bracket_inner"));
		hud.rotating_bracket_size = boost::json::value_to<double>(hud_object.at("rotating_bracket_size"));
		hud.rotating_bracket_width = boost::json::value_to<double>(hud_object.at("rotating_bracket_width"));
		hud.scale_relationship_color = boost::json::value_to<int>(hud_object.at("scale_relationship_color"));
		hud.shield_vdu_fade = boost::json::value_to<bool>(hud_object.at("shield_vdu_fade"));
		hud.shield_vdu_thresh0 = boost::json::value_to<int>(hud_object.at("shield_vdu_thresh0"));
		hud.shield_vdu_thresh1 = boost::json::value_to<double>(hud_object.at("shield_vdu_thresh1"));
		hud.shield_vdu_thresh2 = boost::json::value_to<double>(hud_object.at("shield_vdu_thresh2"));
		hud.show_negative_blips_as_positive = boost::json::value_to<bool>(hud_object.at("show_negative_blips_as_positive"));
		hud.simple_manifest = boost::json::value_to<bool>(hud_object.at("simple_manifest"));
		hud.starship_near_message = boost::json::value_to<std::string>(hud_object.at("starship_near_message"));
		hud.switch_to_target_mode_on_key = boost::json::value_to<bool>(hud_object.at("switch_to_target_mode_on_key"));
		hud.switch_back_from_comms = boost::json::value_to<bool>(hud_object.at("switch_back_from_comms"));
		hud.tac_target_foci = boost::json::value_to<double>(hud_object.at("tac_target_foci"));
		hud.tac_target_length = boost::json::value_to<double>(hud_object.at("tac_target_length"));
		hud.tac_target_thickness = boost::json::value_to<int>(hud_object.at("tac_target_thickness"));
		hud.text_background_alpha = boost::json::value_to<double>(hud_object.at("text_background_alpha"));
		hud.top_view = boost::json::value_to<bool>(hud_object.at("top_view"));
		hud.untarget_beyond_cone = boost::json::value_to<bool>(hud_object.at("untarget_beyond_cone"));

		boost::json::object graphics_object = root_object.at("graphics").get_object();
		graphics.resolution_x = boost::json::value_to<int>(graphics_object.at("resolution_x"));
		graphics.resolution_y = boost::json::value_to<int>(graphics_object.at("resolution_y"));
		graphics.screen = boost::json::value_to<int>(graphics_object.at("screen"));

		boost::json::object glow_flicker_object = graphics_object.at("glow_flicker").get_object();
		graphics.glow_flicker.flicker_time = boost::json::value_to<int>(glow_flicker_object.at("flicker_time"));
		graphics.glow_flicker.flicker_off_time = boost::json::value_to<int>(glow_flicker_object.at("flicker_off_time"));
		graphics.glow_flicker.min_flicker_cycle = boost::json::value_to<int>(glow_flicker_object.at("min_flicker_cycle"));
		graphics.glow_flicker.num_times_per_second_on = boost::json::value_to<double>(glow_flicker_object.at("num_times_per_second_on"));
		graphics.glow_flicker.hull_for_total_dark = boost::json::value_to<double>(glow_flicker_object.at("hull_for_total_dark"));
		graphics.automatic_landing_zone_warning = boost::json::value_to<std::string>(graphics_object.at("automatic_landing_zone_warning"));
		graphics.automatic_landing_zone_warning1 = boost::json::value_to<std::string>(graphics_object.at("automatic_landing_zone_warning1"));
		graphics.automatic_landing_zone_warning2 = boost::json::value_to<std::string>(graphics_object.at("automatic_landing_zone_warning2"));
		graphics.automatic_landing_zone_warning_text = boost::json::value_to<std::string>(graphics_object.at("automatic_landing_zone_warning_text"));
		graphics.draw_heading_marker = boost::json::value_to<bool>(graphics_object.at("draw_heading_marker"));
		graphics.missile_explosion_radius_mult = boost::json::value_to<int>(graphics_object.at("missile_explosion_radius_mult"));
		graphics.missile_sparkle = boost::json::value_to<bool>(graphics_object.at("missile_sparkle"));
		graphics.in_system_jump_ani_second_ahead = boost::json::value_to<int>(graphics_object.at("in_system_jump_ani_second_ahead"));
		graphics.in_system_jump_ani_second_ahead_end = boost::json::value_to<double>(graphics_object.at("in_system_jump_ani_second_ahead_end"));
		graphics.in_system_jump_animation = boost::json::value_to<std::string>(graphics_object.at("in_system_jump_animation"));
		graphics.atmosphere_emmissive = boost::json::value_to<int>(graphics_object.at("atmosphere_emmissive"));
		graphics.atmosphere_diffuse = boost::json::value_to<int>(graphics_object.at("atmosphere_diffuse"));
		graphics.default_engine_activation = boost::json::value_to<double>(graphics_object.at("default_engine_activation"));
		graphics.explosion_animation = boost::json::value_to<std::string>(graphics_object.at("explosion_animation"));
		graphics.shield_detail = boost::json::value_to<int>(graphics_object.at("shield_detail"));
		graphics.shield_texture = boost::json::value_to<std::string>(graphics_object.at("shield_texture"));
		graphics.shield_technique = boost::json::value_to<std::string>(graphics_object.at("shield_technique"));
		graphics.fov = boost::json::value_to<int>(graphics_object.at("fov"));
		graphics.reduced_vdus_width = boost::json::value_to<int>(graphics_object.at("reduced_vdus_width"));
		graphics.reduced_vdus_height = boost::json::value_to<int>(graphics_object.at("reduced_vdus_height"));
		graphics.star_body_radius = boost::json::value_to<double>(graphics_object.at("star_body_radius"));
		graphics.draw_star_glow = boost::json::value_to<bool>(graphics_object.at("draw_star_glow"));
		graphics.draw_star_body = boost::json::value_to<bool>(graphics_object.at("draw_star_body"));
		graphics.star_glow_radius = boost::json::value_to<double>(graphics_object.at("star_glow_radius"));
		graphics.glow_ambient_star_light = boost::json::value_to<bool>(graphics_object.at("glow_ambient_star_light"));
		graphics.glow_diffuse_star_light = boost::json::value_to<bool>(graphics_object.at("glow_diffuse_star_light"));
		graphics.planet_detail_stacks = boost::json::value_to<int>(graphics_object.at("planet_detail_stacks"));
		graphics.wormhole_unit = boost::json::value_to<std::string>(graphics_object.at("wormhole_unit"));
		graphics.city_light_strength = boost::json::value_to<int>(graphics_object.at("city_light_strength"));
		graphics.day_city_light_strength = boost::json::value_to<int>(graphics_object.at("day_city_light_strength"));
		graphics.num_times_to_draw_shine = boost::json::value_to<int>(graphics_object.at("num_times_to_draw_shine"));

		boost::json::object logging_object = root_object.at("logging").get_object();
		logging.vsdebug = boost::json::value_to<int>(logging_object.at("vsdebug"));
		logging.verbose_debug = boost::json::value_to<bool>(logging_object.at("verbose_debug"));

		boost::json::object physics_object = root_object.at("physics").get_object();
		physics.collision_scale_factor = boost::json::value_to<int>(physics_object.at("collision_scale_factor"));
		physics.inelastic_scale = boost::json::value_to<int>(physics_object.at("inelastic_scale"));
		physics.kilojoules_per_damage = boost::json::value_to<int>(physics_object.at("kilojoules_per_damage"));
		physics.max_force_multiplier = boost::json::value_to<int>(physics_object.at("max_force_multiplier"));
		physics.max_shield_lowers_capacitance = boost::json::value_to<int>(physics_object.at("max_shield_lowers_capacitance"));
		physics.max_torque_multiplier = boost::json::value_to<int>(physics_object.at("max_torque_multiplier"));
		physics.minimum_mass = boost::json::value_to<double>(physics_object.at("minimum_mass"));
		physics.minimum_time = boost::json::value_to<int>(physics_object.at("minimum_time"));
		physics.does_missile_bounce = boost::json::value_to<bool>(physics_object.at("does_missile_bounce"));
		physics.default_shield_tightness = boost::json::value_to<int>(physics_object.at("default_shield_tightness"));
		physics.system_damage_on_armor = boost::json::value_to<bool>(physics_object.at("system_damage_on_armor"));
		physics.indiscriminate_system_destruction = boost::json::value_to<double>(physics_object.at("indiscriminate_system_destruction"));
		physics.separate_system_flakiness_component = boost::json::value_to<bool>(physics_object.at("separate_system_flakiness_component"));
		physics.shield_energy_capacitance = boost::json::value_to<double>(physics_object.at("shield_energy_capacitance"));
		physics.use_max_shield_energy_usage = boost::json::value_to<bool>(physics_object.at("use_max_shield_energy_usage"));
		physics.shields_in_spec = boost::json::value_to<bool>(physics_object.at("shields_in_spec"));
		physics.shield_maintenance_charge = boost::json::value_to<double>(physics_object.at("shield_maintenance_charge"));
		physics.max_ecm = boost::json::value_to<int>(physics_object.at("max_ecm"));
		physics.max_lost_target_live_time = boost::json::value_to<double>(physics_object.at("max_lost_target_live_time"));
		physics.percent_missile_match_target_velocity = boost::json::value_to<int>(physics_object.at("percent_missile_match_target_velocity"));
		physics.game_speed = boost::json::value_to<int>(physics_object.at("game_speed"));
		physics.game_accel = boost::json::value_to<int>(physics_object.at("game_accel"));
		physics.combat_mode_multiplier = boost::json::value_to<int>(physics_object.at("combat_mode_multiplier"));
		physics.velocity_max = boost::json::value_to<int>(physics_object.at("velocity_max"));
		physics.max_player_rotation_rate = boost::json::value_to<int>(physics_object.at("max_player_rotation_rate"));
		physics.max_non_player_rotation_rate = boost::json::value_to<int>(physics_object.at("max_non_player_rotation_rate"));
		physics.capship_size = boost::json::value_to<int>(physics_object.at("capship_size"));
		physics.near_autotrack_cone = boost::json::value_to<double>(physics_object.at("near_autotrack_cone"));
		physics.close_enough_to_autotrack = boost::json::value_to<int>(physics_object.at("close_enough_to_autotrack"));
		physics.distance_to_warp = boost::json::value_to<int>(physics_object.at("distance_to_warp"));
		physics.target_distance_to_warp_bonus = boost::json::value_to<double>(physics_object.at("target_distance_to_warp_bonus"));
		physics.no_spec_jump = boost::json::value_to<bool>(physics_object.at("no_spec_jump"));
		physics.difficulty_speed_exponent = boost::json::value_to<double>(physics_object.at("difficulty_speed_exponent"));
		physics.min_damage = boost::json::value_to<double>(physics_object.at("min_damage"));
		physics.max_damage = boost::json::value_to<double>(physics_object.at("max_damage"));
		physics.max_radar_cone_damage = boost::json::value_to<double>(physics_object.at("max_radar_cone_damage"));
		physics.max_radar_lock_cone_damage = boost::json::value_to<double>(physics_object.at("max_radar_lock_cone_damage"));
		physics.max_radar_track_cone_damage = boost::json::value_to<double>(physics_object.at("max_radar_track_cone_damage"));
		physics.thruster_hit_chance = boost::json::value_to<double>(physics_object.at("thruster_hit_chance"));
		physics.friendly_auto_radius = boost::json::value_to<int>(physics_object.at("friendly_auto_radius"));
		physics.neutral_auto_radius = boost::json::value_to<int>(physics_object.at("neutral_auto_radius"));
		physics.hostile_auto_radius = boost::json::value_to<int>(physics_object.at("hostile_auto_radius"));
		physics.min_asteroid_distance = boost::json::value_to<int>(physics_object.at("min_asteroid_distance"));
		physics.steady_itts = boost::json::value_to<bool>(physics_object.at("steady_itts"));
		physics.no_unit_collisions = boost::json::value_to<bool>(physics_object.at("no_unit_collisions"));
		physics.difficulty_based_shield_recharge = boost::json::value_to<bool>(physics_object.at("difficulty_based_shield_recharge"));
		physics.engine_energy_takes_priority = boost::json::value_to<bool>(physics_object.at("engine_energy_takes_priority"));
		physics.density_of_rock = boost::json::value_to<int>(physics_object.at("density_of_rock"));
		physics.density_of_jump_point = boost::json::value_to<int>(physics_object.at("density_of_jump_point"));
		physics.planet_dock_port_size = boost::json::value_to<double>(physics_object.at("planet_dock_port_size"));
		physics.planet_dock_port_min_size = boost::json::value_to<int>(physics_object.at("planet_dock_port_min_size"));
		physics.jump_mesh_radius_scale = boost::json::value_to<double>(physics_object.at("jump_mesh_radius_scale"));
		physics.planets_can_have_subunits = boost::json::value_to<bool>(physics_object.at("planets_can_have_subunits"));
		physics.planets_always_neutral = boost::json::value_to<bool>(physics_object.at("planets_always_neutral"));
		physics.no_damage_to_docked_ships = boost::json::value_to<bool>(physics_object.at("no_damage_to_docked_ships"));
		physics.difficulty_based_enemy_damage = boost::json::value_to<bool>(physics_object.at("difficulty_based_enemy_damage"));
		physics.speeding_discharge = boost::json::value_to<double>(physics_object.at("speeding_discharge"));
		physics.min_shield_speeding_discharge = boost::json::value_to<double>(physics_object.at("min_shield_speeding_discharge"));
		physics.nebula_shield_recharge = boost::json::value_to<double>(physics_object.at("nebula_shield_recharge"));

		boost::json::object unit_object = root_object.at("unit").get_object();
		unit.default_aggressivity = boost::json::value_to<double>(unit_object.at("default_aggressivity"));

		boost::json::object ftl_object = root_object.at("ftl").get_object();
		ftl.insystem_jump_cost = boost::json::value_to<double>(ftl_object.at("insystem_jump_cost"));
		ftl.max_effective_velocity = boost::json::value_to<double>(ftl_object.at("max_effective_velocity"));
		ftl.bleed_factor = boost::json::value_to<int>(ftl_object.at("bleed_factor"));
		ftl.warp_energy_multiplier = boost::json::value_to<double>(ftl_object.at("warp_energy_multiplier"));
		ftl.player_warp_energy_multiplier = boost::json::value_to<double>(ftl_object.at("player_warp_energy_multiplier"));
		ftl.warp_ramp_up_time = boost::json::value_to<int>(ftl_object.at("warp_ramp_up_time"));
		ftl.computer_warp_ramp_up_time = boost::json::value_to<int>(ftl_object.at("computer_warp_ramp_up_time"));
		ftl.warp_ramp_down_time = boost::json::value_to<double>(ftl_object.at("warp_ramp_down_time"));
		ftl.warp_memory_effect = boost::json::value_to<double>(ftl_object.at("warp_memory_effect"));
		ftl.warp_stretch_cutoff = boost::json::value_to<int>(ftl_object.at("warp_stretch_cutoff"));
		ftl.warp_stretch_decel_cutoff = boost::json::value_to<int>(ftl_object.at("warp_stretch_decel_cutoff"));
		ftl.warp_multiplier_min = boost::json::value_to<double>(ftl_object.at("warp_multiplier_min"));
		ftl.warp_multiplier_max = boost::json::value_to<int>(ftl_object.at("warp_multiplier_max"));
		ftl.use_warp_energy_for_cloak = boost::json::value_to<bool>(ftl_object.at("use_warp_energy_for_cloak"));

		boost::json::object weapons_object = root_object.at("weapons").get_object();
		weapons.can_fire_in_cloak = boost::json::value_to<bool>(weapons_object.at("can_fire_in_cloak"));
		weapons.can_fire_in_spec = boost::json::value_to<bool>(weapons_object.at("can_fire_in_spec"));

		boost::json::object components_object = root_object.at("components").get_object();

		boost::json::object afterburner_object = components_object.at("afterburner").get_object();

		boost::json::object drive_object = components_object.at("drive").get_object();
		components.drive.non_combat_mode_multiplier = boost::json::value_to<int>(drive_object.at("non_combat_mode_multiplier"));

		boost::json::object energy_object = components_object.at("energy").get_object();
		components.energy.factor = boost::json::value_to<int>(energy_object.at("factor"));

		boost::json::object fuel2_object = components_object.at("fuel2").get_object();
		components.fuel2.fuel_equals_warp = boost::json::value_to<bool>(fuel2_object.at("fuel_equals_warp"));
		components.fuel2.factor = boost::json::value_to<int>(fuel2_object.at("factor"));

		boost::json::object ftl_drive_object = components_object.at("ftl_drive").get_object();
		components.ftl_drive.factor = boost::json::value_to<double>(ftl_drive_object.at("factor"));

		boost::json::object ftl_energy_object = components_object.at("ftl_energy").get_object();
		components.ftl_energy.factor = boost::json::value_to<int>(ftl_energy_object.at("factor"));

		boost::json::object jump_drive_object = components_object.at("jump_drive").get_object();
		components.jump_drive.factor = boost::json::value_to<int>(jump_drive_object.at("factor"));

		boost::json::object reactor_object = components_object.at("reactor").get_object();
		components.reactor.factor = boost::json::value_to<int>(reactor_object.at("factor"));

		boost::json::object constants_object = root_object.at("constants").get_object();
		constants.megajoules_multiplier = boost::json::value_to<int>(constants_object.at("megajoules_multiplier"));
		constants.kilo = boost::json::value_to<int>(constants_object.at("kilo"));
		constants.kj_per_unit_damage = boost::json::value_to<int>(constants_object.at("kj_per_unit_damage"));

		boost::json::object game_start_object = root_object.at("game_start").get_object();
		game_start.default_mission = boost::json::value_to<std::string>(game_start_object.at("default_mission"));
		game_start.introduction = boost::json::value_to<std::string>(game_start_object.at("introduction"));

		boost::json::object advanced_object = root_object.at("advanced").get_object();

    }
    catch (std::exception const& e)
    {
        std::cerr << e.what() << std::endl;
    }
}

std::shared_ptr<Configuration> configuration() {
    static std::shared_ptr<Configuration> kConfiguration = nullptr;
    
    if(kConfiguration == nullptr) {
        std::ifstream ifs("config.json", std::ifstream::in);
        std::stringstream buffer;
        if(!ifs.fail()) {
            buffer << ifs.rdbuf();
            const std::string json_text = buffer.str();
            kConfiguration = std::make_shared<Configuration>(json_text);
        }
    }
    
    return kConfiguration;
}