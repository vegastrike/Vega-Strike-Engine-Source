<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Boost.Geometry.Index: Predicates (boost::geometry::index::)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Boost.Geometry.Index
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Predicates (boost::geometry::index::)</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac52a6557110425d4ece53fbd6f9ff866"><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr class="memitem:gac52a6557110425d4ece53fbd6f9ff866"><td class="memTemplItemLeft" align="right" valign="top">detail::predicates::spatial_predicate<br class="typebreak"/>
&lt; Geometry, <br class="typebreak"/>
detail::predicates::contains_tag, <br class="typebreak"/>
false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#gac52a6557110425d4ece53fbd6f9ff866">boost::geometry::index::contains</a> (Geometry const &amp;g)</td></tr>
<tr class="memdesc:gac52a6557110425d4ece53fbd6f9ff866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate <code><a class="el" href="group__predicates.html#gac52a6557110425d4ece53fbd6f9ff866" title="Generate contains() predicate. ">contains()</a></code> predicate.  <a href="#gac52a6557110425d4ece53fbd6f9ff866">More...</a><br/></td></tr>
<tr class="separator:gac52a6557110425d4ece53fbd6f9ff866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02dbb7cca47de0b921ef96af464d9590"><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr class="memitem:ga02dbb7cca47de0b921ef96af464d9590"><td class="memTemplItemLeft" align="right" valign="top">detail::predicates::spatial_predicate<br class="typebreak"/>
&lt; Geometry, <br class="typebreak"/>
detail::predicates::covered_by_tag, <br class="typebreak"/>
false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#ga02dbb7cca47de0b921ef96af464d9590">boost::geometry::index::covered_by</a> (Geometry const &amp;g)</td></tr>
<tr class="memdesc:ga02dbb7cca47de0b921ef96af464d9590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate <code><a class="el" href="group__predicates.html#ga02dbb7cca47de0b921ef96af464d9590" title="Generate covered_by() predicate. ">covered_by()</a></code> predicate.  <a href="#ga02dbb7cca47de0b921ef96af464d9590">More...</a><br/></td></tr>
<tr class="separator:ga02dbb7cca47de0b921ef96af464d9590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e92e4a20dd19185584fe85847439108"><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr class="memitem:ga0e92e4a20dd19185584fe85847439108"><td class="memTemplItemLeft" align="right" valign="top">detail::predicates::spatial_predicate<br class="typebreak"/>
&lt; Geometry, <br class="typebreak"/>
detail::predicates::covers_tag, <br class="typebreak"/>
false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#ga0e92e4a20dd19185584fe85847439108">boost::geometry::index::covers</a> (Geometry const &amp;g)</td></tr>
<tr class="memdesc:ga0e92e4a20dd19185584fe85847439108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate <code><a class="el" href="group__predicates.html#ga0e92e4a20dd19185584fe85847439108" title="Generate covers() predicate. ">covers()</a></code> predicate.  <a href="#ga0e92e4a20dd19185584fe85847439108">More...</a><br/></td></tr>
<tr class="separator:ga0e92e4a20dd19185584fe85847439108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aa114ab16f40c8caeb3338adba5d6da"><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr class="memitem:ga0aa114ab16f40c8caeb3338adba5d6da"><td class="memTemplItemLeft" align="right" valign="top">detail::predicates::spatial_predicate<br class="typebreak"/>
&lt; Geometry, <br class="typebreak"/>
detail::predicates::disjoint_tag, <br class="typebreak"/>
false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#ga0aa114ab16f40c8caeb3338adba5d6da">boost::geometry::index::disjoint</a> (Geometry const &amp;g)</td></tr>
<tr class="memdesc:ga0aa114ab16f40c8caeb3338adba5d6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate <code><a class="el" href="group__predicates.html#ga0aa114ab16f40c8caeb3338adba5d6da" title="Generate disjoint() predicate. ">disjoint()</a></code> predicate.  <a href="#ga0aa114ab16f40c8caeb3338adba5d6da">More...</a><br/></td></tr>
<tr class="separator:ga0aa114ab16f40c8caeb3338adba5d6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78cb2ef221b951867c591ffb51b7d8c5"><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr class="memitem:ga78cb2ef221b951867c591ffb51b7d8c5"><td class="memTemplItemLeft" align="right" valign="top">detail::predicates::spatial_predicate<br class="typebreak"/>
&lt; Geometry, <br class="typebreak"/>
detail::predicates::intersects_tag, <br class="typebreak"/>
false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#ga78cb2ef221b951867c591ffb51b7d8c5">boost::geometry::index::intersects</a> (Geometry const &amp;g)</td></tr>
<tr class="memdesc:ga78cb2ef221b951867c591ffb51b7d8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate <code><a class="el" href="group__predicates.html#ga78cb2ef221b951867c591ffb51b7d8c5" title="Generate intersects() predicate. ">intersects()</a></code> predicate.  <a href="#ga78cb2ef221b951867c591ffb51b7d8c5">More...</a><br/></td></tr>
<tr class="separator:ga78cb2ef221b951867c591ffb51b7d8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a6d33e6f61ad5bff3bdee50a972d54b"><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr class="memitem:ga4a6d33e6f61ad5bff3bdee50a972d54b"><td class="memTemplItemLeft" align="right" valign="top">detail::predicates::spatial_predicate<br class="typebreak"/>
&lt; Geometry, <br class="typebreak"/>
detail::predicates::overlaps_tag, <br class="typebreak"/>
false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#ga4a6d33e6f61ad5bff3bdee50a972d54b">boost::geometry::index::overlaps</a> (Geometry const &amp;g)</td></tr>
<tr class="memdesc:ga4a6d33e6f61ad5bff3bdee50a972d54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate <code><a class="el" href="group__predicates.html#ga4a6d33e6f61ad5bff3bdee50a972d54b" title="Generate overlaps() predicate. ">overlaps()</a></code> predicate.  <a href="#ga4a6d33e6f61ad5bff3bdee50a972d54b">More...</a><br/></td></tr>
<tr class="separator:ga4a6d33e6f61ad5bff3bdee50a972d54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabce901b82af2aab10ebbd0dda12f4d5"><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr class="memitem:gaabce901b82af2aab10ebbd0dda12f4d5"><td class="memTemplItemLeft" align="right" valign="top">detail::predicates::spatial_predicate<br class="typebreak"/>
&lt; Geometry, <br class="typebreak"/>
detail::predicates::within_tag, <br class="typebreak"/>
false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#gaabce901b82af2aab10ebbd0dda12f4d5">boost::geometry::index::within</a> (Geometry const &amp;g)</td></tr>
<tr class="memdesc:gaabce901b82af2aab10ebbd0dda12f4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate <code><a class="el" href="group__predicates.html#gaabce901b82af2aab10ebbd0dda12f4d5" title="Generate within() predicate. ">within()</a></code> predicate.  <a href="#gaabce901b82af2aab10ebbd0dda12f4d5">More...</a><br/></td></tr>
<tr class="separator:gaabce901b82af2aab10ebbd0dda12f4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3213772dd3e54ad03340c2ca66b4f58c"><td class="memTemplParams" colspan="2">template&lt;typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:ga3213772dd3e54ad03340c2ca66b4f58c"><td class="memTemplItemLeft" align="right" valign="top">detail::predicates::satisfies<br class="typebreak"/>
&lt; UnaryPredicate, false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#ga3213772dd3e54ad03340c2ca66b4f58c">boost::geometry::index::satisfies</a> (UnaryPredicate const &amp;pred)</td></tr>
<tr class="memdesc:ga3213772dd3e54ad03340c2ca66b4f58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate <a class="el" href="group__predicates.html#ga3213772dd3e54ad03340c2ca66b4f58c" title="Generate satisfies() predicate. ">satisfies()</a> predicate.  <a href="#ga3213772dd3e54ad03340c2ca66b4f58c">More...</a><br/></td></tr>
<tr class="separator:ga3213772dd3e54ad03340c2ca66b4f58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8772d9d3e5b12b3292f7d94d47310e3e"><td class="memTemplParams" colspan="2">template&lt;typename Geometry &gt; </td></tr>
<tr class="memitem:ga8772d9d3e5b12b3292f7d94d47310e3e"><td class="memTemplItemLeft" align="right" valign="top">detail::predicates::nearest<br class="typebreak"/>
&lt; Geometry &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#ga8772d9d3e5b12b3292f7d94d47310e3e">boost::geometry::index::nearest</a> (Geometry const &amp;geometry, unsigned k)</td></tr>
<tr class="memdesc:ga8772d9d3e5b12b3292f7d94d47310e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate <a class="el" href="group__predicates.html#ga8772d9d3e5b12b3292f7d94d47310e3e" title="Generate nearest() predicate. ">nearest()</a> predicate.  <a href="#ga8772d9d3e5b12b3292f7d94d47310e3e">More...</a><br/></td></tr>
<tr class="separator:ga8772d9d3e5b12b3292f7d94d47310e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac52a6557110425d4ece53fbd6f9ff866"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::contains_tag, false&gt; boost::geometry::index::contains </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate <code><a class="el" href="group__predicates.html#gac52a6557110425d4ece53fbd6f9ff866" title="Generate contains() predicate. ">contains()</a></code> predicate. </p>
<p>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <code>bg::within(Geometry, Indexable)</code> returns true.</p>
<dl class="section user"><dt>Example</dt><dd><pre class="fragment">bgi::query(spatial_index, bgi::contains(box), std::back_inserter(result));
</pre></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>The Geometry type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The Geometry object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga02dbb7cca47de0b921ef96af464d9590"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::covered_by_tag, false&gt; boost::geometry::index::covered_by </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate <code><a class="el" href="group__predicates.html#ga02dbb7cca47de0b921ef96af464d9590" title="Generate covered_by() predicate. ">covered_by()</a></code> predicate. </p>
<p>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <code>bg::covered_by(Indexable, Geometry)</code> returns true.</p>
<dl class="section user"><dt>Example</dt><dd><pre class="fragment">bgi::query(spatial_index, bgi::covered_by(box), std::back_inserter(result));
</pre></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>The Geometry type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The Geometry object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0e92e4a20dd19185584fe85847439108"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::covers_tag, false&gt; boost::geometry::index::covers </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate <code><a class="el" href="group__predicates.html#ga0e92e4a20dd19185584fe85847439108" title="Generate covers() predicate. ">covers()</a></code> predicate. </p>
<p>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <code>bg::covered_by(Geometry, Indexable)</code> returns true.</p>
<dl class="section user"><dt>Example</dt><dd><pre class="fragment">bgi::query(spatial_index, bgi::covers(box), std::back_inserter(result));
</pre></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>The Geometry type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The Geometry object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0aa114ab16f40c8caeb3338adba5d6da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::disjoint_tag, false&gt; boost::geometry::index::disjoint </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate <code><a class="el" href="group__predicates.html#ga0aa114ab16f40c8caeb3338adba5d6da" title="Generate disjoint() predicate. ">disjoint()</a></code> predicate. </p>
<p>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <code>bg::disjoint(Indexable, Geometry)</code> returns true.</p>
<dl class="section user"><dt>Example</dt><dd><pre class="fragment">bgi::query(spatial_index, bgi::disjoint(box), std::back_inserter(result));
</pre></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>The Geometry type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The Geometry object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga78cb2ef221b951867c591ffb51b7d8c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::intersects_tag, false&gt; boost::geometry::index::intersects </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate <code><a class="el" href="group__predicates.html#ga78cb2ef221b951867c591ffb51b7d8c5" title="Generate intersects() predicate. ">intersects()</a></code> predicate. </p>
<p>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <code>bg::intersects(Indexable, Geometry)</code> returns true.</p>
<dl class="section user"><dt>Example</dt><dd><pre class="fragment">bgi::query(spatial_index, bgi::intersects(box), std::back_inserter(result));
bgi::query(spatial_index, bgi::intersects(ring), std::back_inserter(result));
bgi::query(spatial_index, bgi::intersects(polygon), std::back_inserter(result));
</pre></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>The Geometry type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The Geometry object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8772d9d3e5b12b3292f7d94d47310e3e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::predicates::nearest&lt;Geometry&gt; boost::geometry::index::nearest </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate <a class="el" href="group__predicates.html#ga8772d9d3e5b12b3292f7d94d47310e3e" title="Generate nearest() predicate. ">nearest()</a> predicate. </p>
<p>When nearest predicate is passed to the query, k-nearest neighbour search will be performed. <code><a class="el" href="group__predicates.html#ga8772d9d3e5b12b3292f7d94d47310e3e" title="Generate nearest() predicate. ">nearest()</a></code> predicate takes a <code>Geometry</code> from which distances to <code>Values</code> are calculated and the maximum number of <code>Values</code> that should be returned. Internally boost::geometry::comparable_distance() is used to perform the calculation.</p>
<dl class="section user"><dt>Example</dt><dd><pre class="fragment">bgi::query(spatial_index, bgi::nearest(pt, 5), std::back_inserter(result));
bgi::query(spatial_index, bgi::nearest(pt, 5) &amp;&amp; bgi::intersects(box), std::back_inserter(result));
bgi::query(spatial_index, bgi::nearest(box, 5), std::back_inserter(result));
</pre></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Only one <code><a class="el" href="group__predicates.html#ga8772d9d3e5b12b3292f7d94d47310e3e" title="Generate nearest() predicate. ">nearest()</a></code> predicate may be used in a query.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geometry</td><td>The geometry from which distance is calculated. </td></tr>
    <tr><td class="paramname">k</td><td>The maximum number of values to return. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4a6d33e6f61ad5bff3bdee50a972d54b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::overlaps_tag, false&gt; boost::geometry::index::overlaps </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate <code><a class="el" href="group__predicates.html#ga4a6d33e6f61ad5bff3bdee50a972d54b" title="Generate overlaps() predicate. ">overlaps()</a></code> predicate. </p>
<p>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <code>bg::overlaps(Indexable, Geometry)</code> returns true.</p>
<dl class="section user"><dt>Example</dt><dd><pre class="fragment">bgi::query(spatial_index, bgi::overlaps(box), std::back_inserter(result));
</pre></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>The Geometry type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The Geometry object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3213772dd3e54ad03340c2ca66b4f58c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::predicates::satisfies&lt;UnaryPredicate, false&gt; boost::geometry::index::satisfies </td>
          <td>(</td>
          <td class="paramtype">UnaryPredicate const &amp;&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate <a class="el" href="group__predicates.html#ga3213772dd3e54ad03340c2ca66b4f58c" title="Generate satisfies() predicate. ">satisfies()</a> predicate. </p>
<p>A wrapper around user-defined UnaryPredicate checking if Value should be returned by spatial query.</p>
<dl class="section user"><dt>Example</dt><dd><pre class="fragment">bool is_red(Value const&amp; v) { return v.is_red(); }

struct is_red_o {
template &lt;typename Value&gt; bool operator()(Value const&amp; v) { return v.is_red(); }
}

// ...

rt.query(index::intersects(box) &amp;&amp; index::satisfies(is_red),
std::back_inserter(result));

rt.query(index::intersects(box) &amp;&amp; index::satisfies(is_red_o()),
std::back_inserter(result));

#ifndef BOOST_NO_CXX11_LAMBDAS
rt.query(index::intersects(box) &amp;&amp; index::satisfies([](Value const&amp; v) { return v.is_red(); }),
std::back_inserter(result));
#endif
</pre></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UnaryPredicate</td><td>A type of unary predicate function or function object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pred</td><td>The unary predicate function or function object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaabce901b82af2aab10ebbd0dda12f4d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Geometry &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::predicates::spatial_predicate&lt;Geometry, detail::predicates::within_tag, false&gt; boost::geometry::index::within </td>
          <td>(</td>
          <td class="paramtype">Geometry const &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate <code><a class="el" href="group__predicates.html#gaabce901b82af2aab10ebbd0dda12f4d5" title="Generate within() predicate. ">within()</a></code> predicate. </p>
<p>Generate a predicate defining Value and Geometry relationship. Value will be returned by the query if <code>bg::within(Indexable, Geometry)</code> returns true.</p>
<dl class="section user"><dt>Example</dt><dd><pre class="fragment">bgi::query(spatial_index, bgi::within(box), std::back_inserter(result));
</pre></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Geometry</td><td>The Geometry type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The Geometry object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 22 2016 12:41:11 for Boost.Geometry.Index by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
